import logging
from pathlib import Path
from typing import Any, Generator, Iterator, List, Tuple

from hermes.core.helpers import create_text_file, get_resource, read_text_lines

# Get a named logger for this module
logger = logging.getLogger(__name__)


class RowsSelectorException(Exception):
    def __init__(self, message: str) -> None:
        super().__init__(message)
        logger.error(message)


class RowsSelector:
    @staticmethod
    def parameters_resource(container: Path, identifier: str) -> Path:
        return get_resource(container, identifier, ".csvl")

    @staticmethod
    def create(
        container: Path, identifier: str, initial_content: dict[str, Any]
    ) -> None:
        parameters_resource = RowsSelector.parameters_resource(container, identifier)
        with create_text_file(parameters_resource) as text_file:
            text_file.write("# Download parameters, one per line\n")
            text_file.write("# Ignore lines starting with '#'\n")
            text_file.write("# Discard all the text following the character ':'\n")
            for key, value in initial_content.items():
                text_file.write(f"# {key}: {value}\n")

    @staticmethod
    def read(container: Path, identifier: str) -> "RowsSelector":
        def get_item(this_part: str) -> Any:
            try:
                return int(this_part)
            except ValueError:
                return str(this_part)

        def get_values(this_line: str) -> List[str]:
            try:
                keep, discard = this_line.split(":")
                parts = keep.split(",")
                return parts
            except Exception as e:
                message = f"RowsSelector.read.get_values: bad line {this_line}. {e}"
                raise RowsSelectorException(message)

        resource = RowsSelector.parameters_resource(container, identifier)
        lines = [line for line in read_text_lines(resource) if line and line[0] != "#"]
        if lines and len(lines) > 1:
            keys = get_values(lines[0])
            list_of_values = [get_values(this_line) for this_line in lines[1:]]
            return RowsSelector(keys, list_of_values)
        else:
            message = f"RowsSelector.read: bad content in {resource}"
            raise RowsSelectorException(message)

    def __init__(self, keys: List[str], list_of_values: List[List[Any]]) -> None:
        self._keys = keys
        self._list_of_values = list_of_values

    @property
    def keys(self) -> List[str]:
        return self._keys

    @property
    def list_of_values(self) -> List[List[Any]]:
        return self._list_of_values

    def select(self, row: dict[str, Any]) -> bool:
        # Generator that yields each inner list of values
        def get_values() -> Generator[List[str], None, None]:
            yield from self._list_of_values  # Use self._list_of_values here

        # Generator that yields zip iterators (key, value) for each value list.
        # Each yielded item is an iterator representing a single selector (e.g., [('a', '0'), ('b', '1')]).
        def get_selector() -> Generator[Iterator[Tuple[str, str]], None, None]:
            for values in get_values():
                # Zip keys with the current list of values to create a selector iterator
                yield zip(self._keys, values)

        # Function to check if a single row matches a specific selector iterator
        def apply_selector(
            this_row: dict[str, Any], selector: Iterator[Tuple[str, Any]]
        ) -> bool:
            # This is the intended logic: Check if all key-value pairs in the *given* selector
            # match the corresponding values in the row (treating "*" as a wildcard).
            # Note: Iterating through the selector consumes it.
            return all(
                this_row.get(key) == value if value != "*" else True
                for key, value in selector
            )

        def same_length() -> bool:
            return all(len(self._keys) == len(values) for values in get_values())

        # Check if the row matches *any* of the selectors generated by get_selector()
        # We iterate through each selector yielded by get_selector() and apply apply_selector
        # to the row with that specific selector.
        if len(self._keys) == 0:
            logger.warning(f"{self.__class__.__name__}.select: no keys")
            return False
        if len(self._list_of_values) == 0:
            logger.warning(f"{self.__class__.__name__}.select: no list_of_values")
            return False
        if len(row) == 0:
            logger.warning(f"{self.__class__.__name__}.select: no row")
            return False
        if same_length():
            if all(row.get(key, None) for key in self._keys):
                return any(
                    apply_selector(row, selector_item)
                    for selector_item in get_selector()
                )
            else:
                logger.warning(
                    f"{self.__class__.__name__}.select: len(keys) != len(values)"
                )
                return False
        else:
            return False
